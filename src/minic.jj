options {

}

PARSER_BEGIN(MiniC)
import java.io.*;

/**  Analyseur lexico-syntaxique Mini-C */
public class MiniC {

  /** Main entry point. */
  public static void main(String args[]) throws ParseException {
      MiniC parser = null ; //new MiniC(System.in);
      try {
            parser = new MiniC (new FileInputStream("test.txt"));
            parser.Z();
      }
      catch (FileNotFoundException e) {
            System.out.println("File not found. Exiting.") ;
            System.exit(0) ;
      }
      catch(Exception e){
            System.out.println(e);
      }
  }
}

PARSER_END(MiniC)



SKIP : {
  <" ">
| <"\t">
| <"\n">
| <"\r">
}

TOKEN : { < PlusMinus  : "+" | "-" > }
TOKEN : { < TermOp : "*" | "/" > }
TOKEN : { < Compare  : "==" | "<" | ">" | "<=" | ">=" | "!="> }
TOKEN : { < TYPE : "int" | "float" > }
TOKEN : { < COLON : "," > }
TOKEN : { < SEMICOLON : ";" > }
TOKEN : { < ASSIGN : "=" > }
TOKEN : { < FOR : "for" > }
TOKEN : { < WHILE : "while" > }
TOKEN : { < IF : "if" > }
TOKEN : { < ELSE : "else" > }
TOKEN : { < OPENB : "(" > }
TOKEN : { < CLOSEB : ")" > }
TOKEN : { < OPENC : "{" > }
TOKEN : { < CLOSEC : "}" > }
TOKEN : { < NUMBER : (<FLOATNum> | <INTNum>) > }
TOKEN : { < INTNum : (["0"-"9"])+ > }
TOKEN : { < FLOATNum : (<INTNum>"."<INTNum>)+ > }
TOKEN : { < IDENTIFIER : (["a"-"z"])+ > }

void Z() :
{}
{
  Function() <EOF>
}

void Function() :
{}
{
  Type() <IDENTIFIER> <OPENB> ArgList() <CLOSEB> CompoundStmt()
}

void ArgList() :
{}
{
  Arg()
  ArgListR()
}

void ArgListR() :
{}
{
  (
  <COLON>
  Arg()
  ArgListR()
  )?
}

void Arg() :
{}
{
   Type ()
  <IDENTIFIER>
}

void Type() :
{}
{
  <TYPE>
}

void IdentList () :
{}
{
   <IDENTIFIER>
   IdentListF()
}

void IdentListF () :
{}
{
   (
   <COLON>
   IdentList()
   )?
}

void Stmt () :
{}
{
   /*ForStmt*/
   (<FOR> <OPENB> Expr() <SEMICOLON> ForStmtC())

   |
   /*WhileStmt */
   (<WHILE> <OPENB> Expr() <CLOSEB> Stmt())

   |
   /*IFStmt */
   (<IF> <OPENB> Expr() <CLOSEB> Stmt() ElsePart())

   |
   /*CompoundStmt*/
   (<OPENC> A ())

   |
   /*Declaration*/
   (Type ()
   IdentList()
   <SEMICOLON>)

   |
   /*Expression*/
   (Expr()
   <SEMICOLON>)

   |
   /*SemiColon*/
   (<SEMICOLON>)
}

void ElsePart () :
{}
{
   (LOOKAHEAD(1)
   <ELSE>
   Stmt())?
}

void ForStmtC () :
{}
{
   (Expr()
   <SEMICOLON>
   Expr()
   <CLOSEB>
   Stmt())
   |
   (<SEMICOLON>
   <CLOSEB>
   Stmt()
   )
}

void CompoundStmt () :
{}
{
   <OPENC>
   A()
}

void A () :
{}
{
   (StmtList() <CLOSEC>)
   |
   (<CLOSEC>)
}

void StmtList () :
{}
{
   Stmt()
   (StmtList())?
}

void Expr () :
{}
{
   (<IDENTIFIER>
   ExprR ())
   |
   (Rvalue())
}
void ExprR () :
{}
{
   (<ASSIGN>
   Expr ())
   |
   (TermR() MagR() RvalueR())
}

void Rvalue () :
{}
{
   MagB()
   RvalueR()
}
void RvalueR () :
{}
{
   (Compare ()
   Mag()
   RvalueR())?
}
void Compare () :
{}
{
   <Compare>
}

void Mag () :
{}
{
   Term()
   MagR()
}

void MagR () :
{}
{
   (
   <PlusMinus>
   Term()
   MagR())?
}

void Term () :
{}
{
   Factor()
   TermR()
}

void TermR () :
{}
{
   (<TermOp>
   Factor()
   TermR())?
}
void Factor () :
{}
{
   <OPENB> Expr() <CLOSEB>
   |
   (<PlusMinus>
   Factor())

   |
   <IDENTIFIER>

   |
   <NUMBER>
}

/*No identifier conflict*/

void MagB () :
{}
{
   TermB()
   MagR()
}
void TermB () :
{}
{
   FactorB()
   TermR()
}
void FactorB () :
{}
{
   <OPENB> Expr() <CLOSEB>
   |
   (<PlusMinus>
   Factor())

   |
   <NUMBER>
}